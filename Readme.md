hashset
 - set 인터페이스에서 지원하는 구현 클래스이다.
 - 순서대로 입력되지 않고, 일정하게 유지되지 않는다.
 - null 요소도 허용이 된다.
 - 중복을 허용하지 않는다. ( 매력적인 부분 )

중복을 걸러내는 과정
 - 객체를 저장하기 전에 먼저 객체의 hashCode() 메소드를 호출해서
   hashCode를 얻어 낸 다음 저장되어 있는 객체들의 hashCode와 비교한 뒤 
   같은 hashCode가 있다면 다시 equals()메소드로
   두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고
   중복 저장을 하지 않는다.

   선언
   HashSet<Integer> set = new HashSet<Integer>();

   메소드
   add(value) : 값을 추가
   remove(value) : 값 제거
   clera() : 모든 값 삭제
   size() : HashSet 크기
   contains(value) : 값의 여부를 확인

   출력
   System.out.println(set); // 전체 출력

   - get 메소드가 존재하지 않아서 하나의 객체를 가지고 올 수가 없다.
   - 하나의 객체를 가져오기 위해서는 Iterator를 사용해야 한다.
   		- 전체 객체를 대상으로 한 번씩 반복해서 가져오는 반복자이다.
   		- Iterator()메소드를 호출하면 얻을 수 있다.
   		- Iterator()에서 하나의 객체를 가져올 때는 next()를 사용한다.
   		- 먼저 가져올 객체가 있는지 확인하기 위해 hasNext()를 사용하여
   			확인하는것이 좋다.
   			- hasNext()메소드는 가져올 객체가 있으면 true 없으면 false 반환

Iterator iter = set.iterator();
while(iter.hasNext()){
	System.out.println(iter.next());
}


작성되는 변수
매개변수 > 멤버변수 

패키지

쇼핑몰 시스템 개발

작은 프로그램 클래스
Order
User
Product

큰 프로그램 클래스
User , UserManager 등등

위의 클래스를 아래와 같이 분류하면,
*user
  *User 등등

패키지 주의사항
1. 패키지는 사용하는 경우 항상 코드 첫 줄에 패키지 이름을 적어주어야 한다.
2. 패키지의 이름과 위치는 폴더(디렉터리) 위치와 같아야 한다. (필수)
3. 패키지의 이름은 모두 소문자를 사용한다. (관례)
4. 패키지의 이름의 앞 부분에는 일반적으로 회사의 도메인 이름을 거꾸로 사용한다.
  - com.company.myapp과 같이 사용한다. (관례)
  - 수 많은 외부 라이브러리가 함께 사용되면 같은 패키지에 같은 클래스 이름이 존재할 수도 있다.
  - 이렇게 도메인 이름을 거꾸로 사용하면 이런 문제를 방지할 수 있다.
  - 오픈소스나 라이브러리를 만들어서 외부에 제공한다면 위의 관례를 꼭 지키는 것이 좋다.
  - 내가 만든 애플리케이션을 다른 곳에 공유하지 않고, 직접 배포한다면 보통 문제가 되지 않는다.

com.sungilshop

user
  User
  UserService
product
  Product
  ProductService
order
  Order
  OrderService
  OrderHistory


접근제어자
  - 자바는 접근제어자를 제공한다.
  - 접근제어자를 사용하면 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 제한할 수 있다.

예를 들어,
스피커에 들어가는 소프트웨어를 개발한다고 가정.

요구사항 - 음량은 절대로 100을 초과하면 안된다. -> 부품이 고장.

스피커는 볼륨증가, 볼륨감소, 현재음량 확인하는 기능만 구현한다.
  - 볼륨은 10씩 증가 또는 감소
  - 켤 때는 생성자를 통해 초기값(초기음량) 적용할 수 있게 한다.
요구사항은 꼭 지켜서 개발한다.


접근 제어자 종류
  - 자바는 4가지 종류의 접근 제어자를 제공

접근 제어자의 종류
1. private : 모든 외부 호출을 막는다.
2. default : 같은 패키지 안에서 호출은 허용한다.
3. protected : 같은 패키지 안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
4. public : 모든 외부 호출을 허용한다.

private -> default -> protected -> public

접근 제어자는 필드와 메서드, 생성자에 사용된다.
클래스 레벨에도 일부 접근 제어자를 사용할 수 있다. (public, default)

해쉬맵
- ValueType put(KeyType, ValueType value)
  - 해쉬맵에 데이터를 저장한다. 첫 번째 매개변수는 하당 데이터의 key 값, 두 번째 매개변수는 해당 key에 해당하는 value 값이다.
  - 반환하는 값은 해시맵 내에 동일한 key에 해당하는 값이 있다면 그 key에 대한 value를 반환한다.
- ValueType get(KeyType key)
  - key 값에 대한 value 값을 반환한다.
- ValueType getOrDefault(KeyType key, 0)
  - key값에 대한 value 값을 반환한다. key값이 없으면 default값인 0을 반환한다.
- ValueType romove(keyType key)
  - 해쉬맵에서 key에 해당하는 데이터를 삭제한다.
- boolean containsKey(KeyType key)
  - 해쉬맵 안에 해당 key가 있다면 true, 없다면 false를 반환한다.
- void clear()
  - 해쉬맵 안의 모든 데이터를 삭제한다.
- int isEmpty()
  - 해쉬맵 안에 데이터가 없다면 true, 있다면 false를 반환한다.
- int size()
  - 해쉬맵 안에 있는 데이터의 개수를 반환한다.


메서드 오버라이딩 조건
1. 메서드 이름 :
    이름이 같아야 한다.

2. 메서드 매개변수(파라미터) :
    타입, 순서, 개수가 같아야 한다.

3. 반환 타입 :
     반환 타입이 같아야 한다.
        단, 반환 타입이 하위 클래스 타입일 수 있다.

4. 접근 제어자 :
    오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다
        더 제한적이어서는 안된다.
    - 상위 클래스 메서드가 protected로 선언되어 있으며,
      하위 클래스에서의 public 또는 protected로 오버라이드
      할 수 있지만, private, default로 오버라이드 할 수 없다.

5. 예외 :
    오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws로 선언할 수 없다. 하지만 더 적거나
    같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다.(추후)

6. static, final, private : 메서드 오버라이딩 될 수 없다.
    - static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다.
    쉽게 이야기해서 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.
    - final 메서드는 재정의를 금지한다. 상수는 값을 변경할 수 없다.
    -private 메서드는 해당 클래스 내에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다.

7. 생성자는 오버라이딩 할 수 없다.



부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다.
이 때 super 키워드를 사용하면 부모를 참조할 수 있다.
super는 이름 그대로 부모 클래스에 대한 참조를 나타낸다.

super - 생성자
상속관계의 인스턴스를 생성하면 결국 메모리 내부에는 자식과 부모 클래스가 각각 다 만들어진다.
Child를 만들면 부모인 Parent까지 함께 만들어지는 거이다. 따라서 각각의 생성자도 모두 호출되어야 한다.
상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.(규칙)
상속 관계에서 부모의 생성자를 호출할 때는 super()를 사용하면 된다.


상속 상품
쇼핑몰의 판매 상품을 보자.
- Bokk, Album, Movie 이렇게 3가지 상품을 클래스로 만들자.
- 코드 중복이 없게 상속 관계를 사용하자. 부모 클래스는 Item이라는 이름을 사용하자.
- 공통 속성 : name, price
  - Book: 저자(author), isbn( isbn )
  - Album: 아티스트( artist )
  - Movie: 감독( director ), 배우( actor )

ShopMain.java

package extends1.ex;

public class ShopMain


    Scanner    : 입력값을 하나씩 들어오면 바로 나감
BefferedReader : 입력값을 한번에 받아서 필요한 만큼 나감




다형성

1. 객체지향 프로그래밍의 대표적인 특성 : 캡슐화, 상속, 다형성 ...
2. 다형성은 객체지향 프로그래밍의 꽃이라 불린다.
3. 다형성은 이름 그대로 '다양한 형태', '여러 형태'를 뜻한다.
4. 프로그래밍에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻한다.
5. 보통 하나의 객체는 하나의 타입으로 고정되어 있는데 다형성을 사용하면 하나의 객체가 다른 타팁으로 사용될 수 있다는 뜻이다.

다형성 2가지 핵심 이론
1. 다형적 참조
2. 메서드 오버라이딩


부모 변수가 자식 인스턴스 참조(다형적 참조) -> 부모는 자식을 품을 수 있다.
// poly.childMethod(); : 자식의 기능을 호출할 수 없다.
// Child child = new Parent(); : 자식은 부모를 담을 수 없다.

UpCasting : poly -> child -> parent // 생략이 가능하기에 생략하면서 사용
DownCasting : poly -> parent -> child // 부모타입를 일시적으로 자식타입으로 변환


추상 클래스
- 동물과 같이 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스라 한다.
- 추상 클래스는 이름 그대로 추상적인 개념을 제공하는 클래스이다. 따라서 실제인 인스턴스가 존재하지 않는다.
- 상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.
- 추상 클래스는 클래스를 선언할 때 앞에 추상이라는 의미의 abstract 키워드를 붙여주면 된다.
- 추상 클래스는 기존 클래스와 완전히 같다. 다만 new Animal()과 같이 직접 인스턴스를 생성하지 못하는 제약이 추가된 것이다.

추상 메서드
- 부모 클래스를 상속 받는 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에서 정의할 수 있다.
- 이것을 추상 메서드라고 한다.
- 추상 메서드는 말 그대로 추상적인 개념을 제공하는 메서드이다. 따라서 실체가 존재하지 않고, 메서드 바디가 없다.
사용법 : public abstract void sound();
- 추상 메서드는 선언할 때 메서드 앞에 abstract 키워드를 붙여주면 된다.
- 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.



클래스 -> 추상 클래스 -> 순수 추상 클래스 -> 인터페이스
즉, 순수 추상 클래스를 더 편리하게 사용할 수 있도록 제공하는게 인터페이스이다.

순수 추상 클래스 특징
1. 인스턴스를 생성할 수 없다.
2. 상속시 모든 메서드를 오버라이딩 해야 한다.
3. 주로 다형성을 위해 사용된다.

인터페이스 특징
1. 앞서 설명한 순수 추상 클래스 특징을 모두 포함한다.
2. 인터페이스 메서드는 모드 public abstract이다.
3. 메서드에 public abstract를 생략할 수 있다. 참고로 생략을 권장
4. 인터페이스는 다중 구현(다중 상속)을 지원한다.

클래스, 추상 클래스, 인터페이스는 모두 똑같다.
- 클래스, 추상 클래스, 인터페이스는 프로그램 코드, 메모리 구조상 모두 똑같다.
- 인터페이스는 순수 추상 클래스와 비슷하다고 생각하면 된다.

상속과 구현
- 상속과 구현은 사람이 표현하는 단어만 다를 뿐이지 자바 입장에서는 똑같다.
- 일반 상속 구조와 동일하게 작동한다.

인터페이스를 사용해야 하는 이유
- 순수 추상 클래스와 인터페이스를 비교했을 때 차이점을 느끼기가 어렵다.
1. 제약 : 순수 추상 클래스는 시간이 지남에 따라 필요에 의해 일반 메서드가 구현할수 있다, 
          그런 경우 순수 추상 클래스에 일반 추상 클래스로 변경될 수 있다.
            인터페이스는 위와 같은일을 원천 차단시킬 수 있다.
2. 다중 구현 : 자바에서는 클래스 상속은 부모 하나만 지정한다.
                반명에 인터페이스는 부모를 여러명 두는 다중 구현

자바가 다중 상속을 지원하지 않는 이유
1. 다중 상속을 사용할 경우 두 부모가 같은 메서드를 가졌을 때 자식에서 호출한 메서드가 어느 부모의
  메서드 인지 알 수 없는 문제가 발생한다. 이것을 다이아몬드 문제라 한다.
2. 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해질 수 있다.

인터페이스의 다중 구현을 허용한 이유
- 인터페이스는 모두 추상 메서드로 이루어져 있기 때문이다.


K3Car
setK3Car()
drive()

startEngine()
offEngine()
pressAccelerator()
